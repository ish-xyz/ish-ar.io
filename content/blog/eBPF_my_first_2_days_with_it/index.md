---
title: eBPF - My first 2 days with it.
date: "2019-07-27T22:25:00.000Z"
description: "In the last two months I kept seeing posts, tweets and articles about eBPF..."
---
## How I ended up studying eBPF...
!['ebpf_logo'](./ebpf_logo.png)

In the last two months I noticed a lot of posts, tweets and articles about eBPF, I was annoyed by this "hype" on my social homepages, because I didn't know absolutely anything regarding it.
So, I googled it, and it turned out it was BPF with an 'e' as first letter :(. At the time I decided to not get involved, since it was "just a packet filter".
But 2 days ago, I read about it in a very clear but still detailed post and my very first thought was: "it absolutely worth part of my time".

Well, I've done my homeworks and tried to get as much info as I could in just 2 days.

## What I've learned so far...?

eBPF which stands for "extended Berkeley Packet Filter", is an in-kernel virtual machine that allows user space programs to be executed in the kernel directly after they succeeded in several checks.

It can be used to do network performance improvements, SDN, security improvements and to have a better kernel debugging / tracing on your systems.
In this article weâ€™ll focus more on its use for analysis purposes.

**NOTE**: in case I'll mention BPF, don't get confused I'm always referring to eBPF.

**What so special about it?**

*Do you remember when you had to writes kernel modules to get data and/or perform debubbing on the Kernel itself? Or maybe solve some system performance issue?*

Well, I don't :D Never done it before and TBH I always thought it was **insane**. Very nerdy, tho.

But looks like thanks to eBPF there is less need of those "insane kernel modules" to perform kernel debugging and performance analysis.

**Why?**

Well, let's see dive a bit inside the eBPF workflow:

!['linux_ebpf_internals'](./linux_ebpf_internals.png)

As you can see from the picture above the BPF programs reside in the user space, probably generated by a frontend software (but we'll talk about those later), the BPF code then will be sent to the BPF VM (which is a register virtual machine and not a stack VM, I'm assuming for performance reasons), and before execute the code, the kernel, has to be sure that your BPF program is safe!

**How it does that?**

By running some checks and sandboxing the code that needs to be executed. I'll probably write another post, in which I'll cover in details all the checks performed by the kernel, but to give you an example: you cannot submit unreachable code, loops, etc otherwise your code will be rejected.
Anyway, finally your code has passed the verifier checks, now the fun part. What makes this feature/tools so incredible is that you can actually attach your code to Kprobes, Jprobes, tracepoints (If you don't know what those are and you can't wait my next post next week-ish, well I'm afraid you'll need to search elsewhere :( ).

**The ADVANTAGE:**
*Instead of dumping all the kernel events and post-process them, you can actually get only the data you need from those probes and tracepoints which eBPF use as data source.*

**How the early retrieved data comes back to the user space?**

They come back through eBPF maps.
Maps is a data structure, a sort of dictionary, k/v array. Through this data structure BPF can actually transfer the data to the u-space.

Ok that's it for today, If I wasn't clear... Well, it has been just 2 days D:

;) Cheers 